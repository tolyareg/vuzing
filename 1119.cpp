

#include <iostream> 
#include <vector>  
#include <queue>  
#include <cmath>  
#include <iomanip> 

using namespace std;

// Константа для представления бесконечности.
const double INF = 9999999;
// Предварительно вычисляем значение sqrt(2) для использования в расчете длины диагонального шага.
const double SQRT2 = sqrt(2.0);

int main() {

    int n, m; // Размеры сетки: N - по горизонтали (запад-восток), M - по вертикали (юг-север).
    cin >> n >> m;

    int k; // Количество кварталов, которые разрешено пересекать по диагонали.
    cin >> k;

    // Создаем 2D массив (вектор векторов) типа bool для хранения информации о возможности диагонального прохода.
    // Размер (n + 1) x (m + 1), чтобы соответствовать 1-based координатам кварталов (от 1 до N и 1 до M).
    // Инициализируем все элементы значением false (по умолчанию диагональный проход запрещен).
    vector<vector<bool>> can_diagonal(n + 1, vector<bool>(m + 1, false));
    for (int i = 0; i < k; ++i) {
        int r, c; // Координаты квартала (1-based), который можно пересечь по диагонали.
        cin >> r >> c;
        // Проверяем, что введенные координаты квартала находятся в допустимых пределах сетки.
        if (r >= 1 && r <= n && c >= 1 && c <= m) {
            // Отмечаем, что через квартал (r, c) разрешен диагональный проход.
            // Это соответствует возможности перехода от перекрестка (r-1, c-1) к (r, c).
            can_diagonal[r][c] = true;
        }
    }

    // Создаем 2D массив для хранения кратчайших расстояний от начального перекрестка (0, 0) до всех остальных.
    // Размер (n + 1) x (m + 1) для перекрестков с координатами от (0, 0) до (N, M).
    // Инициализируем все расстояния значением INF (бесконечность).
    vector<vector<double>> dist(n + 1, vector<double>(m + 1, INF));

    // Создаем очередь с приоритетом для алгоритма Дейкстры.
    // Она будет хранить пары: {текущее_расстояние, {координата_x, координата_y}}.
    // `greater<...>` делает её min-heap, т.е. элементы с наименьшим расстоянием будут иметь наивысший приоритет.
    priority_queue<pair<double, pair<int, int>>, vector<pair<double, pair<int, int>>>, greater<pair<double, pair<int, int>>>> pq;

    // Устанавливаем начальное условие: расстояние до стартового перекрестка (0, 0) равно 0.
    dist[0][0] = 0.0;
    // Добавляем стартовый узел в очередь с приоритетом.
    pq.push({0.0, {0, 0}});

    // Задаем стоимость (длину) шагов.
    double cost_straight = 100.0; // Стоимость прямого шага (горизонтального или вертикального).
    double cost_diagonal = 100.0 * SQRT2; // Стоимость диагонального шага.

    // Основной цикл алгоритма Дейкстры. Продолжается, пока очередь с приоритетом не опустеет.
    while (!pq.empty()) {
        // Извлекаем из очереди узел (перекресток) с наименьшим текущим расстоянием.
        double d = pq.top().first;      // Текущее кратчайшее расстояние до узла (r, c) от старта.
        int r = pq.top().second.first;  // Координата x (индекс строки в 2D массивах)
        int c = pq.top().second.second; // Координата y (индекс столбца в 2D массивах)
        pq.pop(); // Удаляем извлеченный элемент из очереди.

        // Оптимизация: Если извлеченное расстояние 'd' больше, чем уже найденное кратчайшее расстояние
        // до этого узла `dist[r][c]`, то это означает, что мы нашли более короткий путь к `(r, c)` ранее,
        // и текущий извлеченный путь не является оптимальным. Пропускаем его обработку.
        // Используем небольшую погрешность (epsilon, здесь 1e-9) для сравнения чисел с плавающей точкой,
        // чтобы избежать проблем, связанных с неточностью представления `double`.
        if (d > dist[r][c] + 1e-9) {
            continue;
        }

        // Условие завершения: Если мы извлекли целевой перекресток (N, M),
        // то, согласно алгоритму Дейкстры (для неотрицательных весов ребер),
        // найденное расстояние `d` является минимально возможным. Можно прекратить поиск.
        if (r == n && c == m) {
            break;
        }

        // Исследуем соседей текущего узла (r, c):

        // 1. Движение на Восток (вправо) к перекрестку (r+1, c)
        // Проверяем, не выходит ли соседний узел за правую границу сетки (r+1 <= n).
        if (r + 1 <= n) {
            double new_dist = d + cost_straight; // Рассчитываем расстояние до соседа через текущий узел.
            // Если найденный путь через (r, c) к (r+1, c) короче, чем ранее известный путь:
            if (new_dist < dist[r + 1][c] - 1e-9) { // Сравнение с погрешностью.
                dist[r + 1][c] = new_dist; // Обновляем кратчайшее расстояние до (r+1, c).
                pq.push({new_dist, {r + 1, c}}); // Добавляем обновленного соседа в очередь.
            }
        }

        // 2. Движение на Север (вверх) к перекрестку (r, c+1)
        // Проверяем, не выходит ли соседний узел за верхнюю границу сетки (c+1 <= m).
        if (c + 1 <= m) {
            double new_dist = d + cost_straight; // Рассчитываем расстояние до соседа.
            // Если найденный путь короче:
            if (new_dist < dist[r][c + 1] - 1e-9) { // Сравнение с погрешностью.
                dist[r][c + 1] = new_dist; // Обновляем расстояние.
                pq.push({new_dist, {r, c + 1}}); // Добавляем в очередь.
            }
        }

        // 3. Движение по диагонали (на Северо-Восток) к перекрестку (r+1, c+1)
        // Проверяем, находится ли узел (r+1, c+1) в пределах сетки.
        // Также проверяем, разрешен ли диагональный проход через соответствующий квартал (r+1, c+1).
        if (r + 1 <= n && c + 1 <= m && can_diagonal[r + 1][c + 1]) {
            double new_dist = d + cost_diagonal; // Рассчитываем расстояние до соседа по диагонали.
            // Если найденный путь короче:
            if (new_dist < dist[r + 1][c + 1] - 1e-9) { // Сравнение с погрешностью.
                dist[r + 1][c + 1] = new_dist; // Обновляем расстояние.
                pq.push({new_dist, {r + 1, c + 1}}); // Добавляем в очередь.
            }
        }
    }

    // По завершении алгоритма Дейкстры (либо после нахождения цели, либо после опустошения очереди),
    // переменная `dist[n][m]` будет содержать длину кратчайшего пути до целевого перекрестка (N, M).
    // Если цель недостижима (что не должно произойти по условиям задачи), значение останется INF.

    // Округляем полученное расстояние до ближайшего целого числа с помощью функции round().
    // Функция round() возвращает значение типа double, поэтому преобразуем его к целочисленному типу long long
    // (используем long long на всякий случай, чтобы избежать переполнения, хотя int обычно достаточно).
    cout << static_cast<long long>(round(dist[n][m])) << endl;

    return 0;
}
