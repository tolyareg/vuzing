#include <iostream> // Для стандартного ввода/вывода (cin, cout)
#include <vector>   // Для использования динамических массивов (векторов)
#include <utility>  // Для использования pair

using namespace std;

int main() {
    // Оптимизация стандартных операций ввода-вывода
    // Отключает синхронизацию потоков C++ и C (stdio)
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n; // Количество предметов (дисциплин)
    int m; // Количество ограничений (зависимостей)
    cin >> n >> m;

    // Храним ограничения. Каждая пара (s, u) означает, что предмет s должен быть изучен до предмета u.
    vector<pair<int, int>> limitations(m); // Вектор пар для хранения ограничений
    for (int i = 0; i < m; ++i) {
        // Считываем пару предметов для каждого ограничения
        cin >> limitations[i].first >> limitations[i].second;
    }

    // Храним предложенный учебный план (последовательность изучения предметов).
    vector<int> study_plan(n);
    // Храним позицию (индекс, начинающийся с 0) каждого предмета в учебном плане.
    // Размер n+1 для удобства использования 1-основанной индексации номеров предметов
    // (элемент position[0] не будет использоваться, если нумерация предметов с 1).
    vector<int> position(n + 1);
    for (int i = 0; i < n; ++i) {
        // Считываем очередной предмет из предложенного плана
        cin >> study_plan[i];
        // Записываем позицию (индекс i), в которой найден предмет study_plan[i] в плане.
        // Например, если study_plan[2] = 5, то position[5] будет равно 2.
        position[study_plan[i]] = i;
    }

    // Флаг для отслеживания корректности порядка. Изначально считаем порядок корректным.
    bool is_valid = true;

    // Проходим по всем заданным ограничениям
    for (int i = 0; i < m; ++i) {
        // Получаем предметы s и u из текущего ограничения
        int subject_s = limitations[i].first;  // Предмет, который должен идти раньше
        int subject_u = limitations[i].second; // Предмет, который должен идти позже

        // Проверяем, нарушено ли ограничение в предложенном плане:
        // Находится ли позиция предмета s *после* позиции предмета u?
        // Если да, то предложенный порядок некорректен.
        if (position[subject_s] > position[subject_u]) {
            is_valid = false; // Устанавливаем флаг некорректности
            // Нет смысла проверять дальнейшие ограничения, если одно уже нарушено.
            break; // Выходим из цикла проверки ограничений
        }
    }

    // Выводим результат на основе значения флага.
    if (is_valid) {
        // Если флаг остался true, значит все ограничения выполнены
        cout << "YES" << endl; // endl выводит перевод строки и сбрасывает буфер
    } else {
        // Если флаг стал false, значит найдено нарушение
        cout << "NO" << endl;
    }

    return 0; // Указываем операционной системе на успешное завершение программы.
}
